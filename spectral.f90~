MODULE spectral
  USE HTYPE
  USE parameters


  IMPLICIT NONE
CONTAINS

  !--------------------------------------------------------------------------!
  !                           FENE SUBROUTINES                               !
  !--------------------------------------------------------------------------!  


  SUBROUTINE spectral_fp_solver_si(coeffs, v_grad, Id, MAT1, MAT2, MAT3, K_mat, L_mat, M_mat)
    REAL(DP), DIMENSION((2*Nf+1)*Nr) :: coeffs, coeff0
    REAL(DP), DIMENSION(2,2) :: v_grad
    REAL(DP), DIMENSION((2*Nf+1)*Nr , (2*Nf+1)*Nr) :: Id, MAT1, MAT2, MAT3, K_mat, L_mat, M_mat
    REAL(DP), DIMENSION((2*Nf+1)*Nr , (2*Nf+1)*Nr) :: b1L1, b2Dtheta
    REAL(DP), DIMENSION(0:(2*Nf+1)*Nr-1 , 0:(2*Nf+1)*Nr-1) :: R!, LHS_inv
    REAL(DP), DIMENSION(0:(2*Nf+1)*Nr-1 , 0:(2*Nf+1)*Nr-1) :: temp_R

    REAL(DP) :: temp_matmul
    INTEGER(DP) :: i,j,k,index_k, time


    b1L1 = .5*(v_grad(1,1) + v_grad(2,2))*MAT3 &
         +.5*( v_grad(1,1)-v_grad(2,2))*MAT1 + .5*(v_grad(1,2) + v_grad(2,1))*MAT2


    b2Dtheta = .5*(v_grad(2,2)-v_grad(1,1))*K_mat + .5*(v_grad(1,2) + v_grad(2,1))*L_mat + &
         .5*(v_grad(2,1)-v_grad(1,2))*M_mat

    R = dt*b1L1 - dt*b2Dtheta + (1-dt*(v_grad(1,1)+v_grad(2,2)))*Id  

    temp_R = 0.
    DO i = 0,(2*Nf+1)*Nr-1
       DO j = 0,(2*Nf+1)*Nr-1
          temp_matmul = 0
          DO k = 0,Nr-1
             index_k = modulo(i,2*Nf+1) + k*(2*Nf+1)
             temp_matmul = temp_matmul +  LHS_inv(i,index_k)*R(index_k,j)
          ENDDO
          temp_R(i,j) = temp_matmul
       ENDDO
    ENDDO

    coeffs = matmul(temp_R,coeffs)
!!$
!!$    R = matmul(LHS_inv, R)
!!$    coeffs = matmul(R,coeffs)
    !taken care of in hyperbolic solver
!    coeffs = coeffs/integrate_coeff(coeffs)


    print*, "in spectral solver!"
  ENDSUBROUTINE spectral_fp_solver_si


  SUBROUTINE fp_hyperbolic_solver(pdf_coeff,pdf_coeff0, u,v,i,j)
    REAL(DP), DIMENSION(0:N-1, 0:N-1,(2*Nf+1)*Nr) :: pdf_coeff, pdf_coeff0
    REAL(DP) :: u, v
    INTEGER(DP) :: i,j
    REAL(DP), DIMENSION((2*Nf+1)*Nr) :: e_w, n_s


    IF(u .GE. 0 ) THEN
       !get left point - THIS SETS e_w
       e_w = pdf_coeff0(modulo(i-1,N),j,:)
       IF(v .GE. 0)THEN
          !get down point - THIS SETS n_s
          n_s = pdf_coeff0(i,modulo(j-1,N),:)
          pdf_coeff(i,j,:) = -(dt/h)*(  u*(pdf_coeff0(i,j,:) - e_w) + &
               v*(pdf_coeff0(i,j,:) - n_s) ) + pdf_coeff0(i,j,:)
       ELSE
          !get up point - THIS SETS n_s
          n_s = pdf_coeff0(i,modulo(j+1,N),:)
          pdf_coeff(i,j,:) = -(dt/h)*(  u*(pdf_coeff0(i,j,:) - e_w) + &
               v*(n_s - pdf_coeff0(i,j,:)) ) + pdf_coeff0(i,j,:)
       ENDIF

    ELSE
       !get right point
       e_w = pdf_coeff0(modulo(i+1,N),j,:)
       IF(v .GE. 0)THEN
          !get down point - THIS SETS n_s
          n_s = pdf_coeff0(i,modulo(j-1,N),:)
          pdf_coeff(i,j,:) = -(dt/h)*(  u*(e_w - pdf_coeff0(i,j,:)) + &
               v*(pdf_coeff0(i,j,:) - n_s) ) + pdf_coeff0(i,j,:)
       ELSE
          !get up point - THIS SETS n_s
          n_s = pdf_coeff0(i,modulo(j+1,N),:)
          pdf_coeff(i,j,:) = -(dt/h)*(  u*(e_w - pdf_coeff0(i,j,:)) + &
               v*(n_s - pdf_coeff0(i,j,:)) ) + pdf_coeff0(i,j,:)
       ENDIF

    ENDIF

  ENDSUBROUTINE fp_hyperbolic_solver



  SUBROUTINE stress_tensor_computation(pdf_coeff, stress_tensor)
    REAL(DP), DIMENSION((2*Nf+1)*Nr) :: pdf_coeff
    REAL(DP), DIMENSION(2,2) :: stress_tensor

    !---------------- USED FOR TEMPORARY STORAGE ----------------!    
    REAL(DP) :: t11_sum, t12_sum, t22_sum
    INTEGER(DP) :: i00, i10, i11,i
    

    t11_sum = 0.0
    t12_sum = 0.0
    t22_sum = 0.0


    DO i = 1, Nr
       i00 = (i-1_DP)*(2_DP*Nf + 1) + 2_DP*0 - 0 + 1_DP
       i10 = (i-1_DP)*(2_DP*Nf + 1) + 2_DP*1_DP - 0 + 1_DP
       i11 = (i-1_DP)*(2_DP*Nf + 1) + 2_DP*1_DP - 1_DP + 1_DP

       t11_sum = t11_sum + weights(i)*(1_DP-coll_pts(i)**2)*(2_DP*pdf_coeff(i00) + pdf_coeff(i10))
       t22_sum = t22_sum + weights(i)*(1_DP-coll_pts(i)**2)*(2_DP*pdf_coeff(i00) - pdf_coeff(i10))
       t12_sum = t12_sum + weights(i)*(1_DP-coll_pts(i)**2)*pdf_coeff(i11)
    ENDDO

    stress_tensor(1,1) = viscoelastic_eps*(-1 + PI_D*max_b**2*t11_sum/32.0_DP)/De
    stress_tensor(2,2) = viscoelastic_eps*(-1 + PI_D*max_b**2*t22_sum/32.0_DP)/De
    stress_tensor(1,2) = viscoelastic_eps*(     PI_D*max_b**2*t12_sum/32.0_DP)/De
    stress_tensor(2,1) = stress_tensor(1,2)


  ENDSUBROUTINE stress_tensor_computation


  SUBROUTINE spectral_matrices_si(D1, D2, L_inv, Id, MAT1, MAT2, MAT3, K_mat, L_mat, M_mat)
    REAL(DP), DIMENSION(1:Nr, 1:Nr)                  :: D1, D2        ! DERIVATIVE MATRICES
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr,1:(2*Nf+1)*Nr) :: Id  
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr,1:(2*Nf+1)*Nr) :: M0, MAT1, MAT2, MAT3
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr,1:(2*Nf+1)*Nr) :: K_mat, L_mat, M_mat
    REAL(DP), DIMENSION(0:(2*Nf+1)*Nr-1,0:(2*Nf+1)*Nr-1) :: L_inv


    !---------------------- LAPACK ROUTINE VARIABLES -----------------------!
    INTEGER, DIMENSION(1:(2*Nf+1)*Nr) :: IPIV
    INTEGER, PARAMETER                :: LWMAX = 10000000
    INTEGER                           :: LWORK = LWMAX
    INTEGER, DIMENSION(1:LWMAX)       :: WORK
    INTEGER                           :: INFO


    ! BUILD THE M0 AND M1 MATRICES (FROM LOZINSKI PAPER)
    CALL  BUILD_M0(M0, D1, D2)
    CALL  BUILD_mat(MAT1,MAT2, MAT3, K_mat, L_mat, M_mat, D1)

    ! BUILD THE Eq AND R MATRICES (FROM LOZINSKI PAPER)
    L_inv = Id - dt*M0 !THIS MATRIX IS INVERTED BY DGETRF & DGETRI (BELOW)

    ! INVERT Aux1 : ITS INVERSE WILL BE STORED IN LHS_inv
    CALL DGETRF((2*Nf+1)*Nr , (2*Nf+1)*Nr, LHS_inv, (2*Nf+1)*Nr, IPIV, INFO )
    print*, "info = ", info
    CALL DGETRI((2*Nf+1)*Nr, L_inv, (2*Nf+1)*Nr, ipiv, work, lwork, info)
    print*, "info = ", info
  ENDSUBROUTINE spectral_matrices_si
  


  FUNCTION INTEGRATE_COEFF(coeff)!, weight, coll_pts)
    REAL(DP) :: INTEGRATE_COEFF
    REAL(DP) :: integral_sum
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr) :: coeff


    INTEGER(DP) :: j,m,n,u
    integral_sum = 0.0
    j = 0
    n = 0 
    !    DO n = j,Nf
    DO m = 1,Nr          
       u = (m-1)*(2*Nf + 1) + 2*n - j + 1
       integral_sum = integral_sum +&
            (max_b/4.0_DP)*weights(m)*((1-coll_pts(m))*.5_DP)**2_DP*coeff(u)*kron_delta(n,0_DP)*TWOPI_D
    ENDDO
    !    ENDDO

    INTEGRATE_COEFF = integral_sum
  ENDFUNCTION INTEGRATE_COEFF
  
  !!-------------------------------- M0 & M1 COMPUTATION -----------------------------------!!
  !!----------------------------------------------------------------------------------------!!  
  SUBROUTINE BUILD_M0(M0, D1, D2)
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr,1:(2*Nf+1)*Nr) :: M0
    REAL(DP), DIMENSION(1:Nr, 1:Nr) :: D1, D2 !derivative matrices for interior domain

    INTEGER(DP) :: i,j,k,l,n,m,u,v
    REAL(DP) :: temp1, temp2, temp3

    DO j = 0,1
       DO n = j,Nf
          DO m = 1,Nr

             u = (m-1)*(2*Nf + 1) + 2*n - j + 1

             DO i = 0,1
                DO l = i,Nf
                   DO k = 1,Nr           

                      v = (k-1)*(2*Nf + 1) + 2*l - i + 1

                      !!------------------------- M0 COMPUTATION--------------------------!!
                      temp1 = 2*(max_b-8)*(1+coll_pts(m))/(max_b*De*(1-coll_pts(m))) &
                           + 4/(max_b*De)

                      temp2 = 4*(1+coll_pts(m))/(max_b*De)

                      
                      temp3 = 4*coll_pts(m)*(max_b-4)/(max_b*De*(1-coll_pts(m))**2) &
                           + 4*l**2/(max_b*De*(1+coll_pts(m)))

                      M0(u,v) = kron_delta(l,n)*(temp1*D1(m,k) + temp2*D2(m,k) &
                           - temp3*kron_delta(k,m))*kron_delta(i,j)
                      !!------------------------------------------------------------------!!


                   ENDDO
                ENDDO
             ENDDO


          ENDDO
       ENDDO
    ENDDO

  ENDSUBROUTINE BUILD_M0


  SUBROUTINE BUILD_mat(MAT1, MAT2, MAT3, K_mat, L_mat, M_mat, D1)
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr,1:(2*Nf+1)*Nr) :: MAT1, MAT2, MAT3
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr,1:(2*Nf+1)*Nr) :: K_mat, L_mat, M_mat
    REAL(DP), DIMENSION(1:Nr, 1:Nr) :: D1
    REAL(DP), DIMENSION(0:1,0:Nf,0:1,0:Nf) :: Jiljn_matrix,Hiljn_matrix,Kiljn_matrix
    REAL(DP), DIMENSION(0:1,0:Nf,0:1,0:Nf) :: Liljn_matrix,Miljn_matrix

    INTEGER(DP) :: i,j,k,l,n,m,u,v

    REAL(DP) :: temp1

    
    ! IN ORDER TO SPEED UP THE COMPUTATIONS, WE NEED TO PRECOMPUTE THE QUADRATURE MATRICES
    ! Jiljn_matrix
    ! Hiljn_matrix
    ! Kiljn_matrix
    ! Liljn_matrix

    Jiljn_matrix = 0. ; Hiljn_matrix = 0. ; Kiljn_matrix = 0. ; Liljn_matrix = 0. 
    DO i = 0,1
       DO l =i,Nf
          DO j = 0,1
             DO n = j,Nf
                Jiljn_matrix(i,l,j,n) = Jiljn_quad(i,l,j,n)
                Hiljn_matrix(i,l,j,n) = Hiljn_quad(i,l,j,n)
                Kiljn_matrix(i,l,j,n) = Kiljn_quad(i,l,j,n)
                Liljn_matrix(i,l,j,n) = Liljn_quad(i,l,j,n)
                Miljn_matrix(i,l,j,n) = DPhi_x_Phi_quad(i,l,j,n)
             ENDDO
          ENDDO
       ENDDO
    ENDDO

    DO j = 0,1
       DO n = j,Nf
          DO m = 1,Nr

             u = (m-1)*(2*Nf + 1) + 2*n - j + 1

             DO i = 0,1
                DO l = i,Nf
                   DO k = 1,Nr           
                      
                      v = (k-1)*(2*Nf + 1) + 2*l - i + 1
                      
                      !!------------------------- Matrix1 COMPUTATION--------------------------!!
                      temp1 = -2*(1+coll_pts(m))*D1(m,k) &
                           + 4*(1+coll_pts(m))/(1-coll_pts(m))*kron_delta(k,m)
                      
                      
                      MAT1(u,v) = temp1*Jiljn_matrix(i,l,j,n)
                      MAT2(u,v) = temp1*Hiljn_matrix(i,l,j,n)
                      MAT3(u,v) = temp1*kron_delta(i,j)*kron_delta(l,n)


                      !!-----------------------------------------------------------------------!!
                      
                      
                      IF(k==m)THEN
                         K_MAT(u,v) = Kiljn_matrix(i,l,j,n)*kron_delta(k,m)
                         L_MAT(u,v) = Liljn_matrix(i,l,j,n)*kron_delta(k,m)
                      ELSE
                         K_MAT(u,v) = 0
                         L_MAT(u,v) = 0
                      ENDIF


                      M_mat(u,v) = Miljn_matrix(i,l,j,n)*kron_delta(k,m)
                      
!!$                      IF(l == 0 .OR. n==0)THEN
!!$                         
!!$                         IF(l == n .AND. k==m)THEN
!!$                            M_mat(u,v) = 2*l*PI_D*( i*(1-j)*( 1+kron_delta(n,0_DP) )  )*kron_delta(l,n)*kron_delta(k,m)
!!$                         ELSE
!!$                            M_mat(u,v) = 0
!!$                         ENDIF
!!$
!!$                      ELSE
!!$
!!$                         IF(l == n .AND. k==m)THEN
!!$                            M_mat(u,v) =2*l*PI_D*(-(1-i)*j + &
!!$                                 i*(1-j)*( 1+kron_delta(n,0_DP) )  )*kron_delta(l,n)*kron_delta(k,m)
!!$                         ELSE
!!$                            M_mat(u,v) = 0
!!$                         ENDIF
!!$
!!$                      ENDIF

                      
                      
                   ENDDO
                ENDDO
             ENDDO


          ENDDO
       ENDDO
    ENDDO

  ENDSUBROUTINE BUILD_MAT

  !!-------------------- COMPUTATION OF Jiljn AND Kiljn INTEGRALS --------------------------!!
  !!----------------------------------------------------------------------------------------!!
  FUNCTION cos_Phi_x_Phi(i,l,j,n,x)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) ::cos_Phi_x_Phi
    REAL(DP) :: x
    cos_Phi_x_Phi = cos(2*x)*((1-i)*cos(2*l*x) + i*sin(2*l*x))*((1-j)*cos(2*n*x) + j*sin(2*n*x))
  ENDFUNCTION cos_Phi_x_Phi

!!!
  FUNCTION sin_Phi_x_Phi(i,l,j,n,x)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) ::sin_Phi_x_Phi
    REAL(DP) :: x
    sin_Phi_x_Phi = sin(2*x)*((1-i)*cos(2*l*x) + i*sin(2*l*x))*((1-j)*cos(2*n*x) + j*sin(2*n*x))
  ENDFUNCTION sin_Phi_x_Phi

  FUNCTION cos_DPhi_x_Phi(i,l,j,n,x)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: cos_DPhi_x_Phi
    REAL(DP) :: x
    cos_DPhi_x_Phi = cos(2*x)*2*l*(i*cos(2*l*x) - (1-i)*sin(2*l*x))*((1-j)*cos(2*n*x) + j*sin(2*n*x))
  ENDFUNCTION cos_DPhi_x_Phi
!!!

  FUNCTION sin_DPhi_x_Phi(i,l,j,n,x)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) ::sin_DPhi_x_Phi
    REAL(DP) :: x
    sin_DPhi_x_Phi = sin(2*x)*2*l*(i*cos(2*l*x) - (1-i)*sin(2*l*x))*((1-j)*cos(2*n*x) + j*sin(2*n*x))
  ENDFUNCTION sin_DPhi_x_Phi

  FUNCTION Phi_x_Phi(i,l,j,n,x)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) ::Phi_x_Phi
    REAL(DP) :: x
    Phi_x_Phi = ((1-i)*cos(2*l*x) + i*sin(2*l*x))*((1-j)*cos(2*n*x) + j*sin(2*n*x))
  ENDFUNCTION Phi_x_Phi

  FUNCTION Phi_x_Phi_quad(i,l,j,n)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: Phi_x_Phi_quad


    REAL(DP) :: x
    INTEGER(DP), PARAMETER :: N1 = 2**8
    REAL(DP) :: delta_x = TWOPI_D/real(N1)
    REAL(DP) :: XI0, XI1, XI2


    INTEGER(DP) :: index

    XI0 = Phi_x_Phi(i,l,j,n,0.0_DP) + Phi_x_Phi(i,l,j,n,TWOPI_D)
    XI1 = 0.0
    XI2 = 0.0
    DO index = 1, N1-1
       x = index*delta_x
       IF(mod(index,2) == 0)THEN
          XI2 = XI2 + Phi_x_Phi(i,l,j,n,x)
       ELSE
          XI1 = XI1 + Phi_x_Phi(i,l,j,n,x)
       ENDIF
    ENDDO

    Phi_x_Phi_quad = delta_x*(XI0 + 2*XI2 + 4*XI1)/3.0
    Phi_x_Phi_quad = Phi_x_Phi_quad/(PI_D*(1 + kron_delta(n,0_DP)))
  ENDFUNCTION Phi_x_Phi_quad



  FUNCTION DPhi_x_Phi(i,l,j,n,x)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: DPhi_x_Phi
    REAL(DP) :: x
    DPhi_x_Phi = 2*l*(i*cos(2*l*x) - (1-i)*sin(2*l*x))*((1-j)*cos(2*n*x) + j*sin(2*n*x))
  ENDFUNCTION DPhi_x_Phi

  FUNCTION DPhi_x_Phi_quad(i,l,j,n)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: DPhi_x_Phi_quad


    REAL(DP) :: x
    INTEGER(DP), PARAMETER :: N1 = 2**8
    REAL(DP) :: delta_x = TWOPI_D/real(N1)
    REAL(DP) :: XI0, XI1, XI2


    INTEGER(DP) :: index

    XI0 = DPhi_x_Phi(i,l,j,n,0.0_DP) + DPhi_x_Phi(i,l,j,n,TWOPI_D)
    XI1 = 0.0
    XI2 = 0.0
    DO index = 1, N1-1
       x = index*delta_x
       IF(mod(index,2) == 0)THEN
          XI2 = XI2 + DPhi_x_Phi(i,l,j,n,x)
       ELSE
          XI1 = XI1 + DPhi_x_Phi(i,l,j,n,x)
       ENDIF
    ENDDO

    DPhi_x_Phi_quad = delta_x*(XI0 + 2*XI2 + 4*XI1)/3.0
    DPhi_x_Phi_quad = DPhi_x_Phi_quad/(PI_D*(1 + kron_delta(n,0_DP)))
  ENDFUNCTION DPhi_x_Phi_quad



  FUNCTION Jiljn_quad(i,l,j,n)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: Jiljn_quad


    REAL(DP) :: x
    INTEGER(DP), PARAMETER :: N1 = 2**8
    REAL(DP) :: delta_x = TWOPI_D/real(N1)
    REAL(DP) :: XI0, XI1, XI2


    INTEGER(DP) :: index

    XI0 = cos_Phi_x_Phi(i,l,j,n,0.0_DP) + cos_Phi_x_Phi(i,l,j,n,TWOPI_D)
    XI1 = 0.0
    XI2 = 0.0
    DO index = 1, N1-1
       x = index*delta_x
       IF(mod(index,2) == 0)THEN
          XI2 = XI2 + cos_Phi_x_Phi(i,l,j,n,x)
       ELSE
          XI1 = XI1 + cos_Phi_x_Phi(i,l,j,n,x)
       ENDIF
    ENDDO

    Jiljn_quad = delta_x*(XI0 + 2*XI2 + 4*XI1)/3.0
    Jiljn_quad = Jiljn_quad/(PI_D*(1 + kron_delta(n,0_DP)))
  ENDFUNCTION Jiljn_quad




  FUNCTION Kiljn_quad(i,l,j,n)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: Kiljn_quad


    REAL(DP) :: x
    INTEGER(DP), PARAMETER :: N1 = 2**8
    REAL(DP) :: delta_x = TWOPI_D/real(N1)
    REAL(DP) :: XI0, XI1, XI2


    INTEGER(DP) :: index

    XI0 = sin_DPhi_x_Phi(i,l,j,n,0.0_DP) + sin_DPhi_x_Phi(i,l,j,n,TWOPI_D)
    XI1 = 0.0
    XI2 = 0.0
    DO index = 1, N1-1
       x = index*delta_x
       IF(mod(index,2) == 0)THEN
          XI2 = XI2 + sin_DPhi_x_Phi(i,l,j,n,x)
       ELSE
          XI1 = XI1 + sin_DPhi_x_Phi(i,l,j,n,x)
       ENDIF
    ENDDO

    Kiljn_quad = delta_x*(XI0 + 2*XI2 + 4*XI1)/3.0
    Kiljn_quad = Kiljn_quad/(PI_D*(1 + kron_delta(n,0_DP)))
  ENDFUNCTION Kiljn_quad

!!!
  FUNCTION Hiljn_quad(i,l,j,n)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: Hiljn_quad


    REAL(DP) :: x
    INTEGER(DP), PARAMETER :: N1 = 2**8
    REAL(DP) :: delta_x = TWOPI_D/real(N1)
    REAL(DP) :: XI0, XI1, XI2


    INTEGER(DP) :: index

    XI0 = sin_Phi_x_Phi(i,l,j,n,0.0_DP) + sin_Phi_x_Phi(i,l,j,n,TWOPI_D)
    XI1 = 0.0
    XI2 = 0.0
    DO index = 1, N1-1
       x = index*delta_x
       IF(mod(index,2) == 0)THEN
          XI2 = XI2 + sin_Phi_x_Phi(i,l,j,n,x)
       ELSE
          XI1 = XI1 + sin_Phi_x_Phi(i,l,j,n,x)
       ENDIF
    ENDDO

    Hiljn_quad = delta_x*(XI0 + 2*XI2 + 4*XI1)/3.0
    Hiljn_quad = Hiljn_quad/(PI_D*(1 + kron_delta(n,0_DP)))
  ENDFUNCTION Hiljn_quad


  FUNCTION Liljn_quad(i,l,j,n)
    INTEGER(DP) :: i,l,j,n
    REAL(DP) :: Liljn_quad


    REAL(DP) :: x
    INTEGER(DP), PARAMETER :: N1 = 2**8
    REAL(DP) :: delta_x = TWOPI_D/real(N1)
    REAL(DP) :: XI0, XI1, XI2


    INTEGER(DP) :: index

    XI0 = cos_DPhi_x_Phi(i,l,j,n,0.0_DP) + cos_DPhi_x_Phi(i,l,j,n,TWOPI_D)
    XI1 = 0.0
    XI2 = 0.0
    DO index = 1, N1-1
       x = index*delta_x
       IF(mod(index,2) == 0)THEN
          XI2 = XI2 + cos_DPhi_x_Phi(i,l,j,n,x)
       ELSE
          XI1 = XI1 + cos_DPhi_x_Phi(i,l,j,n,x)
       ENDIF
    ENDDO

    Liljn_quad = delta_x*(XI0 + 2*XI2 + 4*XI1)/3.0
    Liljn_quad = Liljn_quad/(PI_D*(1 + kron_delta(n,0_DP)))
  ENDFUNCTION Liljn_quad
!!!



  !!------------------------------ GAUSS-LEGENDRE ROUTINES ---------------------------------!!
  !!----------------------------------------------------------------------------------------!!

  SUBROUTINE gauss_legendre_nodes_weights(N_pts, collocation_pts, weight)
    INTEGER(DP) :: N_pts
    REAL(DP), DIMENSION(0:N_pts) :: collocation_pts, weight


    REAL(DP) :: Ln, DLn
    INTEGER(DP) :: j,k
    INTEGER(DP) :: max_iterations = 100
    REAL(DP) :: local_delta ! used in iteration inside this routine

    IF(N_pts ==0)THEN
       collocation_pts(0) = 0.0
       weight(0) = 0.0
    ELSEIF(N_pts == 1)THEN
       collocation_pts(0) = -sqrt(1.0/3.0)
       weight(0) = 1.0
       collocation_pts(1) = sqrt(1.0/3.0)
       weight(1) = 1.0
    ELSE
       DO j = 0, INT( (N_pts + 1)/2 ) - 1
          collocation_pts(j) = - cos( (2*j+1)*PI_D/REAL(2*N_pts + 2) )
          !------------------- COMPUTATION OF COLLOCATION POINTS --------------------!
          DO k = 0, max_iterations
             ! COMPUTE LEGENDRE POLYNOMIAL AND DERIVATIVE FOR (N+1, x_j)(ALGORITHM 22)
             ! THIS SHOULD RETURN L_{N+1} AND L'_{N+1}
             CALL legendre_polynomial_derivative(N_pts+1, collocation_pts(j), Ln, DLn)
             local_delta = -Ln/DLn
             collocation_pts(j) = collocation_pts(j) + local_delta
             IF(abs(local_delta) <= 10.0**(-8)*abs(collocation_pts(j))  ) EXIT
             IF( k == max_iterations) print*, "max_iterations reached!!!"
          ENDDO

          CALL legendre_polynomial_derivative(N_pts+1, collocation_pts(j), Ln, DLn)

          collocation_pts(N_pts-j) = -collocation_pts(j)
          weight(j) = 2.0/( (1-collocation_pts(j)**2)*(DLn**2) )
          weight(N_pts - j) = weight(j)

       ENDDO
    ENDIF

    IF( MOD(N_pts,2) == 0)THEN
       CALL legendre_polynomial_derivative(N_pts+1, 0.0_DP, Ln, DLn)
       collocation_pts(N_pts/2) = 0.0
       weight(N_pts/2) = 2.0/DLn**2
    ENDIF
  ENDSUBROUTINE gauss_legendre_nodes_weights




  SUBROUTINE legendre_polynomial_derivative(N_pts,x, Ln, DLn)
    INTEGER(DP) :: N_pts
    REAL(DP) :: x
    REAL(DP) :: Ln, DLn  !RETURNED - LEG. POLY AND ITS DERIVATIVE EVALUATED AT x
    REAL(DP) :: Ln_1, DLn_1
    REAL(DP) :: Ln_2, DLn_2

    INTEGER(DP) :: k

    IF(N_pts == 0 )THEN
       Ln = 1
       DLn = 0
    ELSEIF(N_pts == 1 )THEN
       Ln = x
       DLn = 1
    ELSE
       Ln_2 = 1
       Ln_1 = x
       DLn_2 = 0
       DLn_1 = 1

       DO k = 2, N_pts
          Ln = (2*k-1)*x*Ln_1/REAL(k) - (k-1)*Ln_2/REAL(k)
          DLn = DLn_2 + (2*k-1)*Ln_1
          Ln_2 = Ln_1
          Ln_1 = Ln
          DLn_2 = DLn_1
          DLn_1 = DLn
       ENDDO

    ENDIF

  ENDSUBROUTINE legendre_polynomial_derivative

  SUBROUTINE derivative_matrix(N_pts, nodes, D_matrix)
    ! ALGORITHM 37
    INTEGER(DP) :: N_pts
    REAL(DP), DIMENSION(0:N_pts) :: nodes
    REAL(DP), DIMENSION(0:N_pts, 0:N_pts) :: D_matrix

    REAL(DP), DIMENSION(0:N_pts) :: b_weight
    INTEGER(DP) :: i,j


    CALL barycentric_weights(N_pts, b_weight, nodes)


    DO i = 0, N_pts
       D_matrix(i,i) = 0
       DO j = 0, N_pts
          IF( i .ne. j)THEN
             D_matrix(i,j) = b_weight(j)/( b_weight(i)*(nodes(i) - nodes(j)))
             D_matrix(i,i) = D_matrix(i,i) - D_matrix(i,j)
          ENDIF
       ENDDO
    ENDDO

  ENDSUBROUTINE derivative_matrix


  SUBROUTINE barycentric_weights(N_pts, b_weight, nodes)
    ! ALGORITHM 30
    INTEGER(DP) :: N_pts
    REAL(DP), DIMENSION(0:N_pts) :: b_weight, nodes

    INTEGER(DP) :: j,k

    b_weight = 1.0

    DO j = 1, N_pts
       DO k = 0, j-1
          b_weight(k) = b_weight(k)*(nodes(k) - nodes(j))
          b_weight(j) = b_weight(j)*(nodes(j) - nodes(k))
       ENDDO
    ENDDO

    DO j = 0, N_pts
       b_weight(j) = 1/b_weight(j)
    ENDDO

  ENDSUBROUTINE barycentric_weights





  FUNCTION coeff_index(i1,i2,i3)
    INTEGER(DP) :: coeff_index, i1,i2,i3
    coeff_index = (i1 -1)*(2*Nf+1) + 2*i2 - i3 + 1
  ENDFUNCTION coeff_index




  FUNCTION kron_delta(a,b)
    INTEGER(DP) :: a,b
    INTEGER(DP):: kron_delta
    IF(a==b)THEN
       kron_delta = 1
    ELSE
       kron_delta = 0
    ENDIF

  ENDFUNCTION kron_delta

  SUBROUTINE initial_coeff(coeff_0)
    REAL(DP), DIMENSION(1:(2*Nf+1)*Nr) :: coeff_0
    INTEGER(DP) :: j,n_si ,m,u

    coeff_0 = 0.0
    DO j = 0,1
       DO n_si = j,Nf
          DO m = 1,Nr
             u = (m-1)*(2*Nf + 1) + 2*n_si - j + 1
             coeff_0(u) = 2*kron_delta(0_DP,j)*kron_delta(0_DP,n_si)*&
                  initial_condition(coll_pts(m))/(1.0 + kron_delta(0_DP,n_si))
          ENDDO
       ENDDO
    ENDDO


  ENDSUBROUTINE initial_coeff

  FUNCTION initial_condition(eta)
    REAL(DP) :: initial_condition
    REAL(DP) :: eta

    initial_condition = (max_b + 2_DP)*((1-eta)*.5)**(max_b/2._DP-2._DP)/(TWOPI_D*max_b)
  ENDFUNCTION initial_condition


ENDMODULE spectral
